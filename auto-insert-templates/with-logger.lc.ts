import * as log from "https://deno.land/std/log/mod.ts";
import { parse } from "https://deno.land/std/flags/mod.ts";
const flags = parse(Deno.args, {
  string: ["std-log-level"]
})
const STD_LOG_LEVEL = flags["std-log-level"] as "DEBUG" | "INFO" | "ERROR" | "NOTSET" | "WARNING" | "CRITICAL" || "INFO"
await log.setup({
  handlers: {
    console: new log.handlers.ConsoleHandler(STD_LOG_LEVEL),
  },
  loggers: {
    default: {
      level: STD_LOG_LEVEL,
      handlers: ["console"],
    },
  },
});

log.debug("init")



//////////////////////////////////////////////////////////////////////////////
//                       暴力破解法
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//                        递归法
// 目标数据：从 [1, a^2] 到 (x, y) 坐标系的映射关系，并收集映射至二维数组
// 1. 什么是 n, n-1: 
// 2. 什么是 f(n), f(n-1): 
// 3. 递归终止条件:
// 4. 递归入口 f(n) 是多少：
// 4. 递归退化条件，n 如何退化成 f(n-1)
// 5. 是否有退化失败可能
// 6. 递归结果上聚，f(n) 结果怎么由 f(n-1) 结果构成: 
// 7. 递归调用，需要传递什么参数：
// 8. 是否有爆栈可能：
// 9. 如何转写为非递归方法
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//                        递推法
// 目标数据：最大的滑动窗口长度，条件：数字种类小于等于2
// 1. 递推进化条件，什么是 n, 什么是 n+1: n 是指滑动窗口，n+1是指增大的滑动窗口或者向右滑动的窗口
// 2. 递推初始条件: 由零开始的符合条件的最小窗口
// 3. 递推终止条件：右边界超出数组长度
// 4. 递推结果上聚：f(n+1) 怎么由 f(n) 构成：f(n+1) 是滑动窗口的长度
// 5. 怎么转化为循环: 尾递归参数迭代
//////////////////////////////////////////////////////////////////////////////
